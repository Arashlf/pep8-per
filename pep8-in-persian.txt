‫Python PEP8 به زبان آدمیزاد
===

از جمله مزایایی که برای زبان برنامه‌نویسی پایتون گفته می‌شه این هست که کد‌های این زبان خوانایی بسیار بالایی دارند، امّا حتی این ویژگی هم می‌تونه قربانی سلیقه‌ی شخصی برنامه‌نویس شده و خوانایی رو حداقل برای اشخاص ثالث خواه هم‌تیمی و خواه دیگران بسیار سخت‌تر از کد‌های زبان‌هایی دیگه بکنه. برای رفع این مشکل استانداردی تهیه شده تا حداقل افراد با رعایت قوانین اون بهتر کد‌های هم رو درک کنند، طبیعتاً این کار خیلی مفیده، البته اگه به بهتر شدن کد و مسائلی از جمله open source و … اهمیت بدین.
این استاندارد اصطلاحاً‌PEP نامیده می‌شه که سرواژه‌ی کلمات عبارت Python Enhancement Proposal هست و قوانینش در صفحه‌ی اون در سایت python.org به آدرس:[https://www.python.org/dev/peps/pep-0008](https://www.python.org/dev/peps/pep-0008) موجود هست امّا از اونجایی که درک این قوانین برای مبتدی‌هایی مثل من که حتی درکشون از زبان انگلیسی هم در حد بخور و نمیر هست یه خورده سخته و از اونجای دیگه‌ای که من فعلاً مجبورم اونها رو بخونم و یاد بگیرم تا بیشتر از این کد‌های خودم رو به لجن نکشم تصمیم گرفتم تا جایی که درک می‌کنم و از امتحان و خطا نتیجه می‌گیرم رو بنویسم تا حداقل یه خروجی مفید اضافه هم ازش بگیرم، پس این متن لزوماً مستند و موثق نیست و طبیعاً اشتباهاتی داره حتی بعضی از موارد حذف شدن یا هنوز نوشته نشدن که به امید خدا به مرور زمان و با کمک توصیه‌کننده‌گان عزیز حل می‌شن.
اوّلین چیزی باید در ارتباط با این قوانین باید در نظر داشته باشیم این هست که شما مجاز به زیر پا گذاشتن این قوانین هستین و چیزی که شما رو مجبور به رعایت اون‌ها می‌کنه تصمیم خودتون هست. یعنی شما می‌تونید اصلاً هیچ وقعی بهشون  ننهید و مسیر خودتون رو برید یا دست و پا شکسته تا جایی که می‌تونید رعایتشون کنید و یا حتی جونتون رو پای رعایت اون‌ها بزارید امّا مطمئن باشید کسی از شما به عنوان شهید یاد نمی‌کنه!! تعجب نکنید، چون بعضی جاها مجبورید که این استاندارد رو بشکنید اگر مجبور هم نباشید بدونید که اگر این کار (شکستن استاندارد – عدم رعایتش) رو می‌کردین بهتر بود. اگر براتون سؤال شده که این مواقع کی‌ها هستن چند موردش رو می‌شه اینطوری توضیح داد:
1. زمانی هست که پیروی از قوانین نه تنها باعث افزایش خوانایی برنامه نمی‌شه بلکه بدتر اون رو کاهش می‌ده، حتی برای افرادی که از این قوانین پیروی می‌کنن.
2. یه موقع لازم هست کدی که می‌نویسید با نسخه‌های قدیمی پایتون هماهنگ باشه و اون ورژن از پایتون این خصوصیتی که شما می‌خواین ازش استفاده کنید رو پشتیبانی نمی‌کنه!

تورفتگی:
---
همین‌طور که می‌دونید پایتون بر خلاف زبان‌هایی مثل C و ‭C++‬ برای بلوک‌گذاری از کروشه‌ها و آکولاد‌ها استفاده نمی‌کنه و به جای اون از تورفتگی‌ها استفاده می‌کنه. برای تورفتگی‌ها می‌شه هم از کاراکتر فاصله(space) و هم کاراکتر tab استفاده کرد و حتماً این رو هم می‌دونید که اندازه‌ی tab توی ویرایشگر‌های مختلف متفاوته برای این شدیداً توصیه می‌شه که برای تورفتگی به جای tab از ۴تا فاصله استفاده کنید.
خطوط بلند:
---
حداکثر طول هر خط (حداکثر تعداد کاراکتر‌های موجود در هر خط) برابر ۷۹ هست، بنا به دلایلی از جمله اینکه گویا عرض استاندارد کاغذ A4 هشتاد کاراکتر هست و گویا از قدیم‌الیام هم خروجی ترمینال ‫۸۰ کاراکتر بوده [منابع](https://twitter.com/VahidMaani/status/540191064230232064). ولی قطعاً دستوراتی هستن که طولشون ۸۰ کاراکتر که سهله از ۲۰۰ کاراکتر هم بیشترن، برای نوشتن این‌ها مجبوریم دستور رو به چند خط بشکنیم، قاعده‌ی کلی این هست که خطوط از قسمت داخلی پرانتز‌ها/کروشه‌ها/آکولاد‌ها شکسته بشن امّا مواقعی پیش‌ میاد که این کار امکان‌پذیر نیست پس به انتهای جدیدخط یک کاراکتر \ (backslash) اضافه کرده و خط رو می‌شکنیم. البته به همین راحتی نیست و موارد زیر هستن که دهن برنامه‌نویس رو سرویس می‌کنن:
1. هنگام فراخوانی یک تابع دو حالت امکان‌پذیر هست:
 1.1. همه‌ی آرگومان‌ها توی یه خط جدید هستن،‌ در این حالت خطوط جدید فقط یه تورفتگی می‌گیرن:
```python
foo = long_function_name(
    var_one, var_two,
    var_three, var_four
    )
```
 2.1. چند آرگومان در انتهای همان خط هستن، در این حالت خطوط بعدی باید دقیقاً تا ابتدای اوّلین آرگومان تورفتگی بگیرن، حتی اگر مجبور باشیم یک تورفتگی با تعداد کمتر از ۴فاصله اضافه کنیم، برای نمایش بهتر تعداد تورفتگی‌ها، هر تورفتگی رو با ۳تا نقطه و یک خط‌تیره نشون دادم:
```python
foo = long_function_name(var_one, var_two,
..._..._..._..._..._..._.var_three, var_four
..._..._..._..._..._..._.)
```
2. در موقع تعریف تابع هم همان قوانین فراخوانی توابع مورد استفاده قرار می‌گیرند با این تفاوت که در حالت اوّلشون تعداد تورفتگی یکی بیشتر می‌شه تا خطوط شکسته شده قاطی دستورات داخلی تابع نشن:
```python
def long_function_name(var_one, var_two, var_three,
..._..._..._..._..._...var_four
..._..._..._..._..._...):
..._print(var_one)


def long_function_name(
..._..._var_one, var_two,
..._..._var_three, var_four
..._..._):
..._print(var_one)
```
‫3. اگر میخواین خط رو از نزدیکی عملگر باینری بشکنین حتماً این کار رو بعد از عملگر انجام بدین نه قبل از اون:
```python
if (this_is_one_thing and
    that_is_another_thing):
    do_something()
```
‫4. اگر مجبور هستین که خط رو قبل از عملگر باینری بشکنین حواستون باشه که از یه تورفتگی اضافه استفاده کنید:
```python
if (this_is_one_thing
        and that_is_another_thing):
    do_something()
```
‫5. هنگام شکستن خطوط با کاراکتر backslash (\)، مثلِ حالت قبل تعداد تورفتگی‌های خطوط جدید یکی بیشتر از تعداد تورفتگی‌های دستور بعدی خواهد بود.
پرانتز/براکت/آکولاد بسته می‌تونه در سه تا موقعیت قرار بگیره، اوّلی همون انتهای خط هست،‌ دوّمی در خط جدید و در امتداد تورفتگی‌های خطوط قبلی و در نهایت سوّمی در خط جدید و درست در کاراکتر اوّل هست. راه حل اوّل چندان جالب نیست و نه تنها هی‫چ کمکی به خوانایی کد نمی‌کنه بلکه مجبورمون می‌کنه که بریم دنبال آخر پرانتز/براکت/آکولاد بگردیم، پس بزاریدش کنار. بین راه حل‌های دوّم و سوّم می‌تونید بر حسب سلیقه یکیش رو انتخاب کنید ولی من پیشنهاد می‌کنم دوّمی رو استفاده کنید چون به نظرم بهتره :) (تحمیل سلیقه‌ی شخصی به خواننده :)) ): 
```python
if True:
    my_list = [
        1, 2, 3,
        4, 5, 6
    ]

if True:
    my_list = [
        1, 2, 3,
        4, 5, 6
        ]
result = some_function_that_takes_arguments(
    'a', 'b', 'c',
    'd', 'e', 'f'
)
```
‫در مورد طول خطوط دستورات صحبت کردیم ولی باید این نکته رو هم در نظر داشته باشیم که طول خطوط با ساختار‌های محدود (توضیحات و docstringها) ۷۲ کاراکتر هست. 
